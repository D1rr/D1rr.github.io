---
layout: post
title: 字符串KMP学习笔记
tag: [笔记-字符串]
---
$KMP$算法，全称$Knuth—Morris—Prat$算法。是一种用来在字符串中查找子串的算法。如果找到了，就返回该子串在字符串中的起始位置。  
前置芝士：[字符串前缀后缀$\&$前缀函数](./kmp0.html)   
给予两个字符串：  ```str='ahgusjah'``` ``pat='ah'``  
肉眼可见$pat$在$str$中出现了两次，此时的起始位置（下标）分别为$0$和$6$。
### 算法介绍：  
按理来说，去匹配一个字符串，我们要不停从前往后移动起始位置并逐个对比。若原串长度为$n$，模板串长度为$m$，则有$n$次（实际实现时会是$n-m$次）移动，每次进行$m$次匹配，时间复杂度为$O(m*n)$。  
而$KMP$的使用使时间复杂度下降为$O(m+n)$。  
两者的复杂度不同在：
* 朴素算法在每次匹配失败之后只会跳到下一位并且重新匹配。
* 而$KMP$在匹配失败后，会通过已经得知的匹配成功和不成功的数据得到一个“移动位置"~~（传送坐标）~~。这样就可以通过减少比对次数来节约时间。

所以，$KMP$的重点，就在这个 ~~（传送坐标）~~ $KMP$函数上。（你也可能见过它叫$Next$数组等等名称，不过放心，我们讲的是同一个东西）  
所谓的$KMP$数组，一言蔽之，就是前缀函数。  
为什么是前缀函数？  
样例模拟可能会简单理解一些：
给定字符串```abacaaababa```，在其中匹配``ababa``。  
* 不用肉眼看，用$KMP$的思想来理解，我们在匹配$i=0$时，发现模板串在$j=3$处匹配失败。那么不难看出，在下一次出现重复的aba之前，所有的字符串内容都是没有意义的。  
* 反向思考一下，如果有意义，那么这个子串的前缀函数就应该往前移，直到前面的字符都没有意义为止。  
* 比如``aababa``这一段如果都有意义，那么既然它无法前推，就可以得到``ca``子串在$KMP$中没有意义。  

